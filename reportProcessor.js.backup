const { createClient } = require('@supabase/supabase-js');
const { HumanMessage, SystemMessage } = require('@langchain/core/messages');
const fs = require('fs');
const path = require('path');
const axios = require('axios');
const pdfParse = require('pdf-parse');
const { Mistral } = require('@mistralai/mistralai');

// Initialize Supabase client
const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

// Initialize Mistral client for OCR
const mistral = new Mistral({
  apiKey: process.env.MISTRAL_API_KEY,
});

const { chatWithFallback } = require('./aiUtils');

/**
 * Download file from Supabase storage
 * @param {string} filePath - Path to file in storage
 * @returns {Promise<Buffer>} - File buffer
 */
async function downloadFromStorage(filePath) {
  try {
    // Try buckets in order of likelihood based on actual structure
    const buckets = ['users-file-storage', 'credit-reports', 'uploads', 'documents'];
    
    for (const bucket of buckets) {
      try {
        console.log(`Trying to download from ${bucket}: ${filePath}`);
        const { data, error } = await supabase.storage
          .from(bucket)
          .download(filePath);

        if (!error && data) {
          console.log(`‚úÖ Successfully downloaded from ${bucket}`);
          return Buffer.from(await data.arrayBuffer());
        }
      } catch (bucketError) {
        console.log(`‚ùå Failed to download from ${bucket}:`, bucketError.message);
      }
    }
    
    throw new Error(`File not found in any storage bucket: ${filePath}`);
  } catch (error) {
    console.error('Error downloading file:', error);
    throw new Error(`Failed to download file: ${error.message}`);
  }
}

/**
 * Extract text from PDF using Mistral OCR
 * @param {Buffer} buffer - PDF buffer
 * @returns {Promise<string>} - Extracted text
 */
async function extractTextFromPDF(buffer) {
  try {
    console.log('üîç Extracting text from PDF using Mistral OCR, buffer size:', buffer.length);

    // Convert buffer to base64 data URL for Mistral
    const base64Data = buffer.toString('base64');
    const dataUrl = `data:application/pdf;base64,${base64Data}`;

    console.log('üì§ Sending PDF to Mistral OCR...');

    // Use Mistral OCR API
    const ocrResponse = await mistral.ocr.process({
      model: "mistral-ocr-latest",
      document: {
        type: "document_url",
        documentUrl: dataUrl
      }
    });

    console.log('‚úÖ Mistral OCR completed, pages processed:', ocrResponse.pages?.length || 0);

    // Combine all pages' markdown content
    const extractedText = ocrResponse.pages
      .map(page => page.markdown)
      .join('\n\n');

    console.log('üìù Extracted text length:', extractedText.length);

    if (!extractedText || extractedText.trim().length < 10) {
      throw new Error('Mistral OCR returned insufficient text from PDF');
    }

    return extractedText;

  } catch (error) {
    console.error('‚ùå Mistral OCR error:', error);
    // Fallback to original pdf-parse method
    console.log('üîÑ Falling back to pdf-parse...');
    try {
      const data = await pdfParse(buffer);
      console.log('üìÑ PDF-parse fallback: pages:', data.numpages, 'text length:', data.text.length);
      return data.text;
    } catch (fallbackError) {
      console.error('‚ùå Fallback also failed:', fallbackError);
      throw new Error(`OCR failed: ${error.message}`);
    }
  }
}

/**
 * Extract text from image using Tesseract OCR
 * @param {Buffer} buffer - Image buffer
 * @returns {Promise<string>} - Extracted text
 */
async function extractTextFromImage(buffer, fileName) {
  console.log('‚ö†Ô∏è Local OCR not available in deployment environment');

  // Since local OCR libraries are not supported in Render,
  // return a helpful error message instead of crashing
  return `Unable to extract text from ${fileName}. The document appears to be image-based or scanned.

Please try uploading a text-based PDF or contact support for assistance with document processing.

For credit report analysis, we recommend:
1. Using digital credit reports from your credit bureau
2. Ensuring your PDF contains selectable text (not just images)
3. Contacting support if you need help with scanned documents`;
}

/**
 * Determine if file is PDF or image and extract text
 * @param {Buffer} buffer - File buffer
 * @param {string} fileName - Original file name
 * @returns {Promise<string>} - Extracted text
 */
async function extractText(buffer, fileName) {
  const ext = path.extname(fileName).toLowerCase();

  if (ext === '.pdf') {
    try {
      // First try regular PDF text extraction
      const pdfText = await extractTextFromPDF(buffer);
      if (pdfText && pdfText.trim().length > 100) {
        return pdfText; // Return if we got good text
      }
      
      // If PDF text extraction failed or returned very little text,
      // it might be a scanned PDF - try OCR
      console.log('PDF text extraction yielded insufficient text, trying OCR...');
      return await extractTextFromImage(buffer, fileName);
    } catch (pdfError) {
      console.log('PDF extraction failed, trying OCR:', pdfError.message);
      // Fallback to OCR for scanned PDFs
      return await extractTextFromImage(buffer, fileName);
    }
  }
}

/**
 * Analyze extracted text for errors and violations using OpenAI
 * @param {string} text - Extracted text
 * @returns {Promise<Object>} - Structured analysis
 */
async function analyzeText(text) {
  // Handle empty or very short text
  if (!text || text.trim().length < 50) {
    return {
      summary: "Insufficient text for analysis - PDF may be image-based or corrupted",
      violations: [],
      errors: [{
        type: "extraction_error",
        description: "Could not extract readable text from the document",
        evidence: "Text length: " + (text?.length || 0) + " characters"
      }],
      overall_score: "unknown",
      needs_ocr: true
    };
  }

  // Truncate text to fit within AI token limits (approx 100k characters for 128k tokens)
  const maxLength = 80000;
  const truncatedText = text.length > maxLength ? 
    text.substring(0, maxLength) + '\n\n[Text truncated for analysis due to length...]' : 
    text;
  
  console.log(`Analyzing text of length: ${truncatedText.length} characters (original: ${text.length})`);

  const systemPrompt = `Analyze this credit report and return ONLY JSON with this structure:

{
  "summary": "Brief summary of findings",
  "personal_info_issues": [{"type": "name/address/ssn issue", "description": "Issue details", "evidence": "Quote from report", "severity": "high/medium/low"}],
  "account_issues": [{"account_name": "Creditor name", "account_number": "Number", "status": "Status", "balance": "Balance", "issue_type": "Issue", "evidence": "Quote", "severity": "high/medium/low"}],
  "collection_accounts": [{"creditor_name": "Original creditor", "collection_agency": "Agency name", "account_number": "Number", "balance": "Balance", "fdpca_issues": "Any violations"}],
  "inquiries": [{"creditor_name": "Who inquired", "date": "Date", "purpose": "Purpose", "issue": "Any problems"}],
  "fcra_violations": [{"violation": "Violation type", "evidence": "Quote", "severity": "high/medium/low"}],
  "overall_assessment": {"credit_score_impact": "high/medium/low", "total_accounts_affected": 0, "overall_risk_level": "clean/minor/significant/serious", "priority_actions": ["Action 1", "Action 2"]},
  "dispute_letters_needed": [{"type": "investigation/correction/violation", "target": "Who to contact", "accounts_involved": ["Account names"]}]
}

Extract ALL account names, numbers, creditors, balances, contact info. Look for multiple names/addresses. Return ONLY JSON.`;
      "collection_agency": "Collection agency name and contact info if available",
      "account_number": "Account number",
      "original_balance": "Original amount",
      "current_balance": "Current balance",
      "fdpca_violations": [
        {
          "violation": "Specific FDCPA violation (e.g., time-barred debt, improper communication)",
          "evidence": "Quote showing violation",
          "severity": "high/medium/low"
        }
      ],
      "recommendation": "Action to take regarding this collection"
    }
  ],
  "inquiries": [
    {
      "creditor_name": "Who made the inquiry",
      "date": "Date of inquiry",
      "purpose": "Purpose if stated",
      "issue": "Potential issue (too many, unauthorized, etc.)",
      "evidence": "Quote from report"
    }
  ],
  "fcra_violations": [
    {
      "violation_type": "inaccurate_reporting|outdated_info|unverified_info|mixed_files|etc",
      "description": "Detailed violation description",
      "affected_accounts": ["List of affected account names"],
      "evidence": "Exact quotes from report",
      "cra_responsible": "Equifax/Experian/TransUnion if identifiable",
      "severity": "high/medium/low",
      "dispute_strategy": "How to dispute this violation"
    }
  ],
  "overall_assessment": {
    "credit_score_impact": "high/medium/low negative impact",
    "total_accounts_affected": 0,
    "total_violations_found": 0,
    "overall_risk_level": "clean/minor_issues/significant_issues/serious_violations",
    "priority_actions": ["List of top 3 actions to take"]
  },
  "dispute_letters_needed": [
    {
      "type": "account_investigation|personal_info_correction|fcra_violation|fdpca_complaint",
      "target": "CRA name or creditor name",
      "accounts_involved": ["Account names"],
      "evidence_needed": ["What evidence to include"],
      "timeline": "How long to wait for response"
    }
  ]
}

CRITICAL REQUIREMENTS:
- Extract EVERY account name, number, creditor, balance, status from the text
- Look for multiple addresses, names, SSNs - these are major identity issues
- Identify all collection agencies and their contact information
- Find all hard/soft inquiries and assess if excessive
- Check for FCRA violations like outdated negative items (>7 years old)
- Check FDCPA compliance for collection accounts
- Include exact quotes as evidence for every finding
- Be extremely thorough - analyze every line of the credit report
- Sort issues by severity and impact
- Return ONLY the JSON object`;

  try {
    const { response } = await chatWithFallback([
      new SystemMessage(systemPrompt),
      new HumanMessage(`Analyze this credit report text:\n\n${truncatedText}`)
    ]);

    // Parse the JSON response
    const analysisText = (response && (response.content || response)) ? String(response.content || response).trim() : '';
    console.log('AI Response:', analysisText.substring(0, 200) + '...');
    
    // Remove markdown code blocks if present
    const jsonText = analysisText.replace(/```json\n?|\n?```/g, '').trim();

    let parsed = null;
    try {
      parsed = JSON.parse(jsonText);
    } catch (parseError) {
      console.error('JSON parse error, trying to extract JSON from response');
      const jsonMatch = jsonText.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        try {
          parsed = JSON.parse(jsonMatch[0]);
        } catch (secondParseError) {
          console.error('Still cannot parse JSON');
        }
      }
    }

    // Validate the parsed result with a lightweight validator
    const { simpleValidate } = require('./utils/validateAnalysis');
    if (parsed) {
      const { valid, errors } = simpleValidate(parsed);
      if (!valid) {
        console.warn('Parsed analysis failed validation:', errors);
        // Attach raw response for frontend inspection
        parsed.raw_response = analysisText;
      }
      return parsed;
    }

    // Fallback: return a structured response wrapping raw AI output
    return {
      summary: analysisText.substring(0, 300) || "Analysis completed but parsing failed",
      personal_info_issues: [],
      account_issues: [],
      collection_accounts: [],
      inquiries: [],
      fcra_violations: [],
      overall_assessment: {
        credit_score_impact: "unknown",
        total_accounts_affected: 0,
        total_violations_found: 0,
        overall_risk_level: "unknown",
        priority_actions: ["Review raw analysis manually"]
      },
      dispute_letters_needed: [],
      raw_response: analysisText
    };
  } catch (error) {
    console.error('Error analyzing text:', error);
    return {
      summary: "Analysis failed due to technical error",
      personal_info_issues: [],
      account_issues: [],
      collection_accounts: [],
      inquiries: [],
      fcra_violations: [],
      overall_assessment: {
        credit_score_impact: "unknown",
        total_accounts_affected: 0,
        total_violations_found: 0,
        overall_risk_level: "unknown",
        priority_actions: ["Contact support for analysis assistance"]
      },
      dispute_letters_needed: [],
      error: error.message
    };
  }
}

/**
 * Process a credit report file from storage
 * @param {string} filePath - Path to file in storage
 * @returns {Promise<Object>} - Complete analysis
 */
async function processCreditReport(filePath) {
  try {
    // Download file
    const buffer = await downloadFromStorage(filePath);

    // Extract text
    const text = await extractText(buffer, filePath);

    // Analyze text
    const analysis = await analyzeText(text);

    return {
      filePath,
      extractedText: text,
      analysis,
      processedAt: new Date().toISOString()
    };
  } catch (error) {
    console.error('Error processing credit report:', error);
    return {
      filePath,
      error: error.message,
      processedAt: new Date().toISOString()
    };
  }
}

module.exports = {
  processCreditReport,
  downloadFromStorage,
  extractText,
  analyzeText
};